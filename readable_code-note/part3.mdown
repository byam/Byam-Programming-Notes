# PART III: Reorganizing your code

Higher-level ways to organize large blocks of code and attack problems at the function level

In Part II, we discussed how to change the “loops and logic” of your program to make your code more readable. We described several techniques that required changing the structure of your program in minor ways.
In this part, we’ll discuss larger changes you can make to your code at the function level. Specifically, we’ll cover three ways to reorganize your code:

* Extract “unrelated subproblems” that aren’t related to the primary goal of your program.
* Rearrange your code so it’s doing only one task at a time.
* Describe your code in words first, and use this description to help guide you to a cleaner solution.

Finally, we’ll discuss situations where you can remove code entirely or avoid writing it in the first place—the single best way to make code easy to understand.

* [Chapter 10: EXTRACTING UNRELATED SUBPROBLEMS](#ch10)

    * [Introductory Example: findClosestLocation()](#ch10_intro)
    * [Pure Utility Code](#ch10_pure)
    * [Other General-Purpose Code](#ch10_other)
    * [Create a Lot of General-Purpose Code](#ch10_create)
    * [Project-Specific Functionality](#ch10_project)
    * [Simplifying an Existing Interface](#ch10_simply)
    * [Reshaping an Interface to Your Needs](#ch10_reshape)
    * [Taking Things Too Far](#ch10_take)
    * [Summary](#ch10_summary)


* [Chapter 11: ONE TASK AT A TIME](#ch11)

    * [Tasks Can Be Small](#ch11_tasks)
    * [Extracting Values from an Object](#ch11_extract)
    * [A Larger Example](#ch11_larger)
    * [Summary](#ch11_summary)


* [Chapter 12: TURNING THOUGHTS INTO CODE](#ch12)

    * [Describing Logic Clearly](#ch12_desc)
    * [Knowing Your Libraries Helps](#ch12_lib)
    * [Applying This Method to Larger Problems](#ch12_method)
    * [Summary](#ch12_summary)

* [Chapter 13: WRITING LESS CODE](#ch13)

    * [Don’t Bother Implementing That Feature—You Won’t Need It](#ch13_dont)
    * [Question and Break Down Your Requirements](#ch13_req)
    * [Keeping Your Codebase Small](#ch13_small)
    * [Be Familiar with the Libraries Around You](#ch13_lib)
    * [Example: Using Unix Tools Instead of Coding](#ch13_unix)
    * [Summary](#ch13_summary)


---







<a name="ch10"></a>
# Chapter 10: EXTRACTING UNRELATED SUBPROBLEMS

Engineering is all about breaking down big problems into smaller ones and putting the solutions for those problems back together. Applying this principle to code makes it more robust and easier to read.
The advice for this chapter is to aggressively identify and extract unrelated subproblems. Here’s what we mean:

1. Look at a given function or block of code, and ask yourself, “What is the high-level goal of this code?”
2. For each line of code, ask, “Is it working directly to that goal? Or is it solving an unrelated subproblem needed to meet it?”
3. If enough lines are solving an unrelated subproblem, extract that code into a separate function.

Extracting code into separate functions is something you probably do every day. But for this chapter, we decided to focus on the specific case of extracting unrelated subproblems, where the extracted code is blissfully unaware of why it’s being called.

As you’ll see, it’s an easy technique to apply but can improve your code substantially. Yet for some reason, many programmers don’t use this technique enough. The trick is to actively look for these unrelated subproblems.

In this chapter, we will go through a variety of examples that illustrate this technique for different situations you might run into.



<a name="ch10_intro"></a>
## Introductory Example: findClosestLocation

The high-level goal of the following JavaScript code is, find the location that’s closest to a given point:

```js
// Return which element of 'array' is closest to the given latitude/longitude.
// Models the Earth as a perfect sphere.
var findClosestLocation = function (lat, lng, array) {
    var closest;
    var closest_dist = Number.MAX_VALUE;
    for (var i = 0; i < array.length; i += 1) {
        // Convert both points to radians.
        var lat_rad = radians(lat);
        var lng_rad = radians(lng);
        var lat2_rad = radians(array[i].latitude);
        var lng2_rad = radians(array[i].longitude);

        // Use the "Spherical Law of Cosines" formula.
        var dist = Math.acos(Math.sin(lat_rad) * Math.sin(lat2_rad) +
                             Math.cos(lat_rad) * Math.cos(lat2_rad) *
                             Math.cos(lng2_rad - lng_rad));

        if (dist < closest_dist) {
            closest = array[i];
            closest_dist = dist;
        }
    }
    return closest;
};

```

Most of the code inside the loop is working on an unrelated subproblem: *Compute the spherical distance between two lat/long points.* Because there is so much of that code, it makes sense to extract it into a separate spherical_distance() function:

```js
var spherical_distance = function (lat1, lng1, lat2, lng2) {
    var lat1_rad = radians(lat1);
    var lng1_rad = radians(lng1);
    var lat2_rad = radians(lat2);
    var lng2_rad = radians(lng2);

    // Use the "Spherical Law of Cosines" formula.
    return Math.acos(Math.sin(lat1_rad) * Math.sin(lat2_rad) +
                     Math.cos(lat1_rad) * Math.cos(lat2_rad) *
};
```


Now the remaining code becomes:
```js
var findClosestLocation = function (lat, lng, array) {
    var closest;
    var closest_dist = Number.MAX_VALUE;
    for (var i = 0; i < array.length; i += 1) {
        var dist = spherical_distance(lat, lng, array[i].latitude, array[i].longitude);
        if (dist < closest_dist) {
            closest = array[i];
            closest_dist = dist;
        }
    }
    return closest;
};
```

This code is far more readable because the reader can focus on the high-level goal without getting distracted by intense geometry equations.

As an added bonus, spherical_distance() will be easier to test in isolation. And spherical_distance() is the type of function that could be reused in the future. This is why it’s an “unrelated” subproblem—it’s completely self-contained and unaware of how applications are using it.


<a name="ch10_pure"></a>
## Pure Utility Code

There is a core set of basic tasks that most programs do, such as manipulating strings, using hash tables, and reading/writing files.

Often, these “basic utilities” are implemented by the built-in libraries in your programming language. For instance, if you want to read the entire contents of a file, in PHP you can call file_get_contents("filename"), or in Python, you can do open("filename").read().

But sometimes you have to fill in the gaps yourself. In C++, for instance, there is no succinct way to read an entire file. Instead, you inevitably end up writing code like this:

```c++
ifstream file(file_name);

// Calculate the file's size, and allocate a buffer of that size.
file.seekg(0, ios::end);
const int file_size = file.tellg();
char* file_buf = new char [file_size];

// Read the entire file into the buffer.
file.seekg(0, ios::beg);
file.read(file_buf, file_size);
file.close();
...

```

This is a classic example of an unrelated subproblem that should be extracted into a new function like ReadFileToString(). Now, the rest of your codebase can act as if C++ did have a ReadFileToString() function.

In general, if you find yourself thinking, “I wish our library had an XYZ() function,” go ahead and write it! (Assuming it doesn’t already exist.) Over time, you’ll build up a nice collection of utility code that can be used across projects.


<a name="ch10_other"></a>
## Other General-Purpose Code

When debugging JavaScript, programmers often use alert() to pop up a message box that displays some information to the programmer, the Web’s version of “printf() debugging.” For example, the following function call submits data to the server using Ajax and then displays the dictionary returned from the server:

```js
ajax_post({
    url: 'http://example.com/submit',
    data: data,
    on_success: function (response_data) {
        var str = "{\n";
        for (var key in response_data) {
            str += "  " + key + " = " + response_data[key] + "\n";
        }
        alert(str + "}");
        // Continue handling 'response_data' ...
    }
});
```

The high-level goal of this code is, Make an Ajax call to the server, and handle the response. But a lot of the code is solving the unrelated subproblem, Pretty-print a dictionary. It’s easy to extract that code into a function like format_pretty(obj):

```js
var format_pretty = function (obj) {
    var str = "{\n";
    for (var key in obj) {
        str += "  " + key + " = " + obj[key] + "\n";
    }
    return str + "}";
};
```

#### Unexpected Benefits

Here are some cases format_pretty(obj) doesn’t handle:

* It expects obj to be an object. If instead it’s a plain string (or undefined), the current code
will throw an exception.
* It expects each value of obj to be a simple type. If instead it contains nested objects, the
current code will display them as [object Object], which isn’t very pretty.

Before we separated format_pretty() into its own function, it would have felt like a lot of work to make all these improvements. (In fact, recursively printing nested objects is very difficult without a separate function.)

But now, adding this functionality is easy. Here’s what the improved code looks like:

```js
var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return "null";
    if (obj === undefined) return "undefined";
    if (typeof obj === "string") return '"' + obj + '"';
    if (typeof obj !== "object") return String(obj);

    if (indent === undefined) indent = "";

    // Handle (non-null) objects.
    var str = "{\n";
    for (var key in obj) {
        str += indent + "  " + key + " = ";
        str += format_pretty(obj[key], indent + " ") + "\n";
    }
    return str + indent + "}";
};
```

This covers the shortcomings listed previously and produces output like this:
```js
{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = "hello world"
        }
    }
}
```


<a name="ch10_create"></a>
## Create a Lot of General-Purpose Code

The functions ReadFileToString() and format_pretty() are great examples of unrelated subproblems. They’re so basic and widely applicable that they are likely to be reused across projects. Codebases often have a special directory for code like this (e.g., util/) so that it can be easily shared.

General-purpose code is great because it’s completely decoupled from the rest of your project. Code like this is easier to develop, easier to test, and easier to understand. If only all of your code could be like this!

Think about many of the powerful libraries and systems that you use, such as SQL databases, JavaScript libraries, and HTML templating systems. You don’t have to worry about their internals—those codebases are completely isolated from your project. As a result, your project’s codebase remains small.

The more of your project you can break away as isolated libraries, the better, because the rest of your code will be smaller and easier to think about.


<a name="ch10_project"></a>
## Project-Specific Functionality

Here is an example from a business reviews website. This Python code creates a new Business object and sets its name, url, and date_created:

```python
business = Business()
business.name = request.POST["name"]

url_path_name = business.name.lower()
url_path_name = re.sub(r"['\.]", "", url_path_name)
url_path_name = re.sub(r"[^a-z0-9]+", "-", url_path_name)
url_path_name = url_path_name.strip("-")

business.url = "/biz/" + url_path_name
business.date_created = datetime.datetime.utcnow() business.save_to_database()
```


The url is supposed to be a “clean” version of the name. For example, if the name is “A.C. Joe’s Tire & Smog, Inc.,” the url will be "/biz/ac-joes-tire-smog-inc".

The unrelated subproblem in this code is: Turn a name into a valid URL. We can extract this code quite easily. While we’re at it, we can also precompile the regular expressions (and give them readable names):

```python
CHARS_TO_REMOVE = re.compile(r"['\.]+")
CHARS_TO_DASH = re.compile(r"[^a-z0-9]+")

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub('', text)
    text = CHARS_TO_DASH.sub('-', text)
    return text.strip("-")
```

Now the original code has a much more “regular” pattern:

```python
business = Business()
business.name = request.POST["name"]
business.url = "/biz/" + make_url_friendly(business.name)
business.date_created = datetime.datetime.utcnow()
business.save_to_database()
```


This code requires far less effort to read because you aren’t distracted by the regular expressions and deep string manipulation.

Where should you put the code for make_url_friendly()? It seems like a fairly general function, so it might make sense to put it in a separate util/ directory. On the other hand, those regular expressions were designed with U.S. business names in mind, so perhaps the code should stay in the same file where it’s used. It actually doesn’t matter that much, and you can easily move the definition later on. What’s more important is that make_url_friendly() was extracted at all.

<a name="ch10_simply"></a>
## Simplifying an Existing Interface

Everybody loves when a library offers a clean interface—one that takes few arguments, doesn’t need much setup, and generally requires little effort to use. It makes your code look elegant: simple and powerful at the same time.

But if an interface you’re using isn’t clean, you can still make your own “wrapper” functions that are.

For example, dealing with browser cookies in JavaScript is far from ideal. Conceptually, cookies are a set of name/value pairs. But the interface the browser provides presents a single document.cookie string whose syntax is:
```js
    name1=value1; name2=value2; ...
```


To find the cookie you want, you’re forced to parse this giant string yourself. Here’s an example of code that reads the value for the cookie named "max_results":

```js
var max_results;
var cookies = document.cookie.split(';');
for (var i = 0; i < cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, '');  // remove leading spaces
    if (c.indexOf("max_results=") === 0)
        max_results = Number(c.substring(12, c.length));
}
```


Wow, that’s some ugly code. Clearly, there’s a get_cookie() function waiting to be made so that
we can just write:
```js
var max_results = Number(get_cookie("max_results"));
```

Creating or changing a cookie value is even stranger. You have to set document.cookie to a value
with an exact syntax:
```js
document.cookie = "max_results=50; expires=Wed, 1 Jan 2020 20:53:47 UTC; path=/";
```
That statement looks like it would overwrite all other existing cookies, but (magically) it
doesn’t!

A more ideal interface to setting a cookie would be something like:
```js
set_cookie(name, value, days_to_expire);
```
Erasing a cookie is also unintuitive: you have to set the cookie to expire in the past. Instead,
an ideal interface would be simply:
```js
delete_cookie(name);
```
The lesson here is that you should never have to settle for an interface that’s less than ideal. You can always create your own wrapper functions to hide the ugly details of an interface you’re stuck with.




<a name="ch10_reshape"></a>
## Reshaping an Interface to Your Needs

A lot of code in a program is there just to support other code—for example, setting up inputs to a function or postprocessing the output. This “glue” code often has nothing to do with the real logic of your program. Mundane code like this is a great candidate to be pulled out into separate functions.

For example, let’s say you have a Python dictionary containing sensitive user information like { "username": "...", "password": "..." } and you need to put all that information into a URL. Because it’s sensitive, you decide to encrypt the dictionary first, using a Cipher class.

But Cipher expects a string of bytes as input, not a dictionary. And Cipher returns a string of bytes, but we need something that’s URL-safe. Cipher also takes a number of extra parameters and is pretty cumbersome to use.

What started as a simple task turns into a lot of glue code:
```python
user_info = { "username": "...", "password": "..." }
user_str = json.dumps(user_info)
cipher = Cipher("aes_128_cbc", key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = "http://example.com/?user_info=" + base64.urlsafe_b64encode(encrypted_bytes) ...
```

Even though the problem we’re tackling is Encrypt the user’s information into a URL, the majority of this code is just doing Encrypt this Python object into a URL-friendly string. It’s easy to extract that subproblem:
```python
def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher("aes_128_cbc", key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
```

Then, the resulting code to execute the real logic of the program is simple:

```python
user_info = { "username": "...", "password": "..." }
url = "http://example.com/?user_info=" + url_safe_encrypt(user_info)
```



<a name="ch10_take"></a>
## Taking Things Too Far

As we said at the beginning of the chapter, our goal is to “aggressively identify and extract unrelated subproblems.” We say “aggressively” because most coders aren’t aggressive enough. But it’s possible to get overexcited and take things too far.

For example, the code from the previous section could have been broken down much further, like this:

```python
user_info = { "username": "...", "password": "..." }
url = "http://example.com/?user_info=" + url_safe_encrypt_obj(user_info)

def url_safe_encrypt_obj(obj):
    obj_str = json.dumps(obj)
    return url_safe_encrypt_str(obj_str)

def url_safe_encrypt_str(data):
    encrypted_bytes = encrypt(data)
    return base64.urlsafe_b64encode(encrypted_bytes)

def encrypt(data):
    cipher = make_cipher()
    encrypted_bytes = cipher.update(data)
    encrypted_bytes += cipher.final() # flush out any remaining bytes return encrypted_bytes

def make_cipher():
    return Cipher("aes_128_cbc", key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
```

Introducing all these tiny functions actually hurts readability, because the reader has more to keep track of, and following the path of execution requires jumping around.

There is a small (but tangible) readability cost of adding a new function to your code. In the previous case, nothing is being gained to offset this cost. It may make sense to add these smaller functions if they’re needed by other parts of your project. But until then, there is no need.

<a name="ch10_summary"></a>
## Summary


A simple way to think about this chapter is to separate the generic code from the project- specific code. As it turns out, most code is generic. By building a large set of libraries and helper functions to solve the general problems, what’s left will be a small core of what makes your program unique.

The main reason this technique helps is that it lets the programmer focus on smaller, well- defined problems that are detached from the rest of your project. As a result, the solutions to those subproblems tend to be more thorough and correct. You might also be able to reuse them later.


---

<a name="ch11"></a>
# Chapter 11: ONE TASK AT A TIME

Code that does multiple things at once is harder to understand. A single block of code might be initializing new objects, cleansing data, parsing inputs, and applying business logic, all at the same time. If all that code is woven together, it will be harder to understand than if each “task” is started and completed on its own.

> KEY IDEA::
Code should be organized so that it’s doing only one task at a time.

![ch11](https://github.com/byam/Programming-Notes/blob/master/readable_code-note/ch11.png)

You might have heard the advice that “functions should do only one thing.” Our advice is similar, but isn’t always about function boundaries. Sure, breaking a large function into multiple smaller functions can be good. But even if you don’t do this, you can still organize the code inside that large function so it feels like there are separate logical sections.

Here’s the process we use to make code do “one task at a time”:

1. List out all the “tasks” your code is doing. We use the word “task” very loosely—it could be as small as “make sure this object is valid” or as vague as “iterate through every node in the tree.”
2. Try to separate those tasks as much as you can into different functions or at least different sections of code.


<a name="ch11_tasks"></a>
## Tasks Can Be Small

Suppose there’s a voting widget on a blog where a user can vote a comment “Up” or “Down.” The total score of a comment is the sum over all votes: +1 for each “Up” vote, –1 for each “Down” vote.

When the user clicks one of the buttons (to make/change her vote), the following JavaScript is called:
```js
vote_changed(old_vote, new_vote);  // each vote is "Up", "Down", or ""
```

This function updates the total score and works for all combinations of old_vote/new_vote:

```js
var vote_changed = function (old_vote, new_vote) {
    var score = get_score();

    if (new_vote !== old_vote) {
        if (new_vote === 'Up') {
            score += (old_vote === 'Down' ? 2 : 1);
        } else if (new_vote === 'Down') {
            score -= (old_vote === 'Up' ? 2 : 1);
        } else if (new_vote === '') {
            score += (old_vote === 'Up' ? -1 : 1);
        }
    }
    set_score(score);
};
```


Even though the code is pretty short, it’s doing a lot. There are lots of intricate details, and it’s hard to tell at a glance whether there are any off-by-one errors, typos, or other bugs.

The code may seem to be doing only one thing (updating the score), but there are actually two tasks being performed at once:

1. old_vote and new_vote are being “parsed” into numerical values.
2. score is being updated.

We can make the code easier to read by solving each task separately. The following code solves the first task, of parsing the vote into a numerical value:
```js
var vote_value = function (vote) {
    if (vote === 'Up') {
        return +1;
    }

    if (vote === 'Down') {
        return -1;
    }

    return 0;
};
```

Now the rest of the code can solve the second task, updating score:

```js
var vote_changed = function (old_vote, new_vote) {
    var score = get_score();
    score -= vote_value(old_vote);  // remove the old vote
    score += vote_value(new_vote);  // add the new vote
    set_score(score);
};
```

As you can see, this version of the code takes a lot less mental effort to convince yourself that it works. That’s a big part of what makes code “easy to understand.”


<a name="ch11_extract"></a>
## Extracting Values from an Object


The following illustration shows example input/output:

![ch11-2](https://github.com/byam/Programming-Notes/blob/master/readable_code-note/ch11-2.png)

It seems easy so far, but the tricky part is that any or all of these four values might be missing. Here’s how we dealt with that:

* When choosing the “City,” we preferred to use the “LocalityName” (city/town) if available, then the “SubAdministrativeAreaName” (larger city/county), then the “AdministrativeAreaName” (state/territory).
* If all three were missing, the “City” was affectionately given the default “Middle-of- Nowhere.”
* If the “CountryName” was missing, “Planet Earth” was used as a default.

Here is the code we wrote to implement this task:

```js
var place = location_info["LocalityName"];  // e.g. "Santa Monica"
if (!place) {
    place = location_info["SubAdministrativeAreaName"];  // e.g. "Los Angeles"
}
if (!place) {
    place = location_info["AdministrativeAreaName"];  // e.g. "California"
}
if (!place) {
    place = "Middle-of-Nowhere";
}
if (location_info["CountryName"]) {
    place += ", " + location_info["CountryName"];  // e.g. "USA"
} else {
    place += ", Planet Earth";
}
return place;
```

Sure, it's a little messy, but it got the job done.
But a few days later, we needed to improve the functionality: for locations in the United States, we wanted to display the state instead of the country (if possible). So instead of “Santa Monica, USA” it would return “Santa Monica, California.”
Adding this feature to the previous code would have made it much uglier.

#### Applying “One Task at a Time”

Rather than bend this code to our will, we stopped and realized that it was already doing multiple tasks at the same time:

1. Extracting values from the dictionary location_info
2. Going through a preference order for “City,” defaulting to “Middle-of-Nowhere” if it
couldn’t find anything
3. Getting the “Country,” and using “Planet Earth” if there wasn’t one
4. Updatingplace

So instead, we rewrote the original code to solve each of these tasks independently. The first task (extracting values from location_info) was easy to solve on its own:

```js
var town = location_info["LocalityName"];               // e.g. "Santa Monica"
var city = location_info["SubAdministrativeAreaName"];  // e.g. "Los Angeles"
var state = location_info["AdministrativeAreaName"];     // e.g. "CA"
var country = location_info["CountryName"]; // e.g. "USA"
```

At this point, we were done using location_info and didn’t have to remember those long and unintuitive keys. Instead, we had four simple variables to work with.


Next, we had to figure out what the “second half” of the return value would be:
```js
// Start with the default, and keep overwriting with the most specific value.
var second_half = "Planet Earth";
if (country) {
    second_half = country; }
if (state && country === "USA") {
    second_half = state; }
```

Similarly, we could figure out the “first half”:
```js
var first_half = "Middle-of-Nowhere";
if (state && country !== "USA") {
    first_half = state; }
if (city) {
    first_half = city;
}
if (town) {
    first_half = town;
}
```

Finally, we pieced the information together:
```js
return first_half + ", " + second_half;
```

The “defragmentation” illustration at the beginning of this chapter was actually a representation of the original solution and this new version. Here’s that same illustration, with more details filled in:

### Another Approach

For instance, that earlier series of if statements requires some careful reading to know if every case works correctly. There are actually two subtasks going on simultaneously in that code:
1. Go through a list of variables, and pick the most preferred one that’s available.
2. Use a different list, depending on whether the country is “USA”.

Looking back, you can see that the earlier code has the “if USA” logic interwoven with the rest of the logic. Instead, we can handle the USA and non-USA cases separately:
```js
var first_half, second_half;

if (country === "USA") {
    first_half = town || city || "Middle-of-Nowhere";
    second_half = state || "USA";
} else {
    first_half = town || city || state || "Middle-of-Nowhere";
    second_half = country || "Planet Earth";
}
return first_half + ", " + second_half;
```

In case you aren’t familiar with JavaScript, a || b || c is idiomatic and evaluates to the first
“truthy” value (in this case, a defined, nonempty string). This code has the benefit that it’s very easy to inspect the preference list and update it. Most of the if statements have been swept away, and the business logic is represented by fewer lines of code.

<a name="ch11_larger"></a>
## A Larger Example

In a web-crawling system we built, a function named UpdateCounts() was called to increment various statistics after each web page was downloaded:

```js
void UpdateCounts(HttpDownload hd) {
    counts["Exit State" ][hd.exit_state()]++;       // e.g. "SUCCESS" or "FAILURE"
    counts["Http Response"][hd.http_response()]++;  // e.g. "404 NOT FOUND"
    counts["Content-Type" ][hd.content_type()]++;   // e.g. "text/html"
}
```

Well, that’s how we wish the code looked!

In actuality, the HttpDownload object had none of the methods shown here. Instead, HttpDownload was a very large and complex class, with many nested classes, and we had to fish out those values ourselves. To make matters worse, sometimes those values were missing altogether—in which case we just used "unknown" as the default value.
Because of all this, the real code was quite a mess:

```js
// WARNING: DO NOT STARE DIRECTLY AT THIS CODE FOR EXTENDED PERIODS OF TIME.
void UpdateCounts(HttpDownload hd) {
    // Figure out the Exit State, if available.
    if (!hd.has_event_log() || !hd.event_log().has_exit_state()) {
        counts["Exit State"]["unknown"]++;
    } else {
        string state_str = ExitStateTypeName(hd.event_log().exit_state());
        counts["Exit State"][state_str]++;
    }

    // If there are no HTTP headers at all, use "unknown" for the remaining elements.
    if (!hd.has_http_headers()) {
        counts["Http Response"]["unknown"]++;
        counts["Content-Type"]["unknown"]++; return;
    }

    HttpHeaders headers = hd.http_headers();

    // Log the HTTP response, if known, otherwise log "unknown"
    if (!headers.has_response_code()) {
        counts["Http Response"]["unknown"]++;
    } else {
        string code = StringPrintf("%d", headers.response_code());
        counts["Http Response"][code]++;
    }

    // Log the Content-Type if known, otherwise log "unknown"
    if (!headers.has_content_type()) {
        counts["Content-Type"]["unknown"]++;
    } else {
        string content_type = ContentTypeMime(headers.content_type());
        counts["Content-Type"][content_type]++;
    }
}
```



In particular, this code switches back and forth between different tasks. Here are the different tasks interleaved throughout the code:

1. Using "unknown" as the default value for each key
2. Detecting whether members of HttpDownload are missing
3. Extracting the value and converting it to a string
4. Updatingcounts[]



We can improve the code by separating some of these tasks into distinct regions in the code:
```js
void UpdateCounts(HttpDownload hd) {
    // Task: define default values for each of the values we want to extract
    string exit_state = "unknown";
    string http_response = "unknown";
    string content_type = "unknown";

    // Task: try to extract each value from HttpDownload, one by one
    if (hd.has_event_log() && hd.event_log().has_exit_state()) {
        exit_state = ExitStateTypeName(hd.event_log().exit_state());
    }
    if (hd.has_http_headers() && hd.http_headers().has_response_code()) {
        http_response = StringPrintf("%d", hd.http_headers().response_code());
    }
    if (hd.has_http_headers() && hd.http_headers().has_content_type()) {
        content_type = ContentTypeMime(hd.http_headers().content_type());
}
    // Task: update counts[]
    counts["Exit State"][exit_state]++;
    counts["Http Response"][http_response]++;
    counts["Content-Type"][content_type]++;
}
```

As you can see, the code has three separate regions with the following aims:

1. Define defaults for the three keys we are interested in.
2. Extract the values, if available, for each of these keys, and convert them to strings.
3. Update counts[] for each key/value.

What’s good about these regions is that they’re isolated from one another—while you’re reading one region, you don’t need to think about the other regions.

#### Further Improvements

However, we could also have improved this code another way, by introducing three helper functions:

```js
void UpdateCounts(HttpDownload hd) {
    counts["Exit State"][ExitState(hd)]++;
    counts["Http Response"][HttpResponse(hd)]++;
    counts["Content-Type"][ContentType(hd)]++;
}
```
These functions would extract the corresponding value, or return “unknown”. For example:
```js
string ExitState(HttpDownload hd) {
    if (hd.has_event_log() && hd.event_log().has_exit_state()) {
        return ExitStateTypeName(hd.event_log().exit_state());
    } else {
        return "unknown";
    }
}
```




<a name="ch11_summary"></a>
## Summary

This chapter illustrates a simple technique for organizing your code: do only one task at a time.

If you have code that’s difficult to read, try to list all of the tasks it’s doing. Some of these tasks might easily become separate functions (or classes). Others might just become logical “paragraphs” within a single function. The exact details of how you separate these tasks isn’t as important as the fact that they’re separated. The hard part is accurately describing all the little things your program is doing.



---

<a name="ch12"></a>
# Chapter 12: TURNING THOUGHTS INTO CODE

When explaining a complex idea to someone, it's easy to confuse them with all the little details. It's a valuable skill to be able to explain an idea “in plain English,” so that someone less knowledgeable than you can understand. It requires distilling an idea down to the most important concepts. Doing this not only helps the other person understand but also helps you think about your own ideas more clearly.

In this chapter, we’ll use a simple process that can help you code more clearly:

1. Describe what code needs to do, in plain English, as you would to a colleague.
2. Pay attention to the key words and phrases used in this description.
3. Write your code to match this description.

<a name="ch12_desc"></a>
## Describing Logic Clearly

Here is a snippet of code from a web page in PHP. This code is at the top of a secured page. It checks whether the user is authorized to see the page, and if not, immediately returns a page telling the user she is not authorized:

```js
$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin && ($document['username'] != $_SESSION['username'])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    }
}

// continue rendering the page ...
```

The logic in this code can probably be simplified, but how? Let’s start by describing the logic in plain English:

There are two ways you can be authorized:

1. you are an admin
2. you own the current document (if there is one)

Otherwise, you are not authorized.


Here is an alternative solution inspired by this description:
```js
if (is_admin_request()) {
    // authorized
} elseif ($document && ($document['username'] == $_SESSION['username'])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
```

This version is slightly unusual because it has two empty bodies. But the code is smaller, and the logic is simpler, because there is no negation. (The previous solution had three “nots.”) The bottom line is that it’s easier to understand.



<a name="ch12_lib"></a>
## Knowing Your Libraries Helps

We once had a website that included a “tips box” that showed the user helpful suggestions like:
```
    Tip: Log in to see your past queries. [Show me another tip!]
```

There were a few dozen tips, and all of them were hidden inside the HTML:
```html
    <div id="tip-1" class="tip">Tip: Log in to see your past queries.</div>
    <div id="tip-2" class="tip">Tip: Click on a picture to see it close up.</div>
    ...
```

When a user visited the page, one of these divs was randomly made visible, and the rest stayed hidden.

If the “Show me another tip!" link was clicked, it cycled to the next tip. Here is some code to implement that feature using the jQuery JavaScript library:

```js
var show_next_tip = function () {
    var num_tips = $('.tip').size();
    var shown_tip = $('.tip:visible');
    var shown_tip_num = Number(shown_tip.attr('id').slice(4));
    if (shown_tip_num === num_tips) {
        $('#tip-1').show();
    } else {
        $('#tip-' + (shown_tip_num + 1)).show();
    }
    shown_tip.hide();
};
```

This code is okay. But it can be made better. Let’s start by describing, in words, what this code is trying to do:

* Find the currently visible tip and hide it.
* Then find the next tip after it and show that.
* If we've run out of tips, cycle back to the first tip.

Based on this description, here’s another solution:
```js
var show_next_tip = function () {
    var cur_tip = $('.tip:visible').hide(); // find the currently visible tip and hide it
    var next_tip = cur_tip.next('.tip');    // find the next tip after it
    if (next_tip.size() === 0) {            // if we've run out of tips,
        next_tip = $('.tip:first');         //     cycle back to the first tip
    next_tip.show();                        // show the new tip
```

This solution contains fewer lines of code and doesn’t have to manipulate integers directly. It’s more aligned with how a person would think about the code.

In this case, it helped that jQuery has a .next() method we could use. Part of writing succinct code is being aware of what your library has to offer.

<a name="ch12_method"></a>
## Applying This Method to Larger Problems

Imagine we have a system that records stock purchases. Each transaction has four pieces of data:

* time (a precise date and time of the purchase)
* ticker_symbol (e.g., GOOG)
* price (e.g., $600)
* number_of_shares (e.g., 100)

For some strange reason, the data is spread across three separate database tables, as illustrated here. In each database, the time is the unique primary key.

![ch12](https://github.com/byam/Programming-Notes/blob/master/readable_code-note/ch12.png)


Now we need to write a program to join the three tables back together (as an SQL JOIN operation would do). This step should be easy because the rows are all sorted by time, but unfortunately some of the rows are missing. You want to find all the rows where all three times match up, and ignore any rows that can’t be lined up, as shown in the previous illustration.

Here is some Python code that finds all the matching rows:

```python
def PrintStockTransactions():
    stock_iter = db_read("SELECT time, ticker_symbol FROM ...")
    price_iter = ...
    num_shares_iter = ...

    # Iterate through all the rows of the 3 tables in parallel.
    while stock_iter and price_iter and num_shares_iter:
        stock_time = stock_iter.time
        price_time = price_iter.time
        num_shares_time = num_shares_iter.time

        # If all 3 rows don't have the same time, skip over the oldest row
        # Note: the "<=" below can't just be "<" in case there are 2 tied-oldest.
        if stock_time != price_time or stock_time != num_shares_time:
            if stock_time <= price_time and stock_time <= num_shares_time:
                stock_iter.NextRow()
            elif price_time <= stock_time and price_time <= num_shares_time:
                price_iter.NextRow()
            elif num_shares_time <= stock_time and num_shares_time <= price_time:
                num_shares_iter.NextRow()
            else:
                assert False  # impossible
            continue
        assert stock_time == price_time == num_shares_time

        # Print the aligned rows. print "@", stock_time,
        print stock_iter.ticker_symbol,
        print price_iter.price,
        print num_shares_iter.number_of_shares

        stock_iter.NextRow()
        price_iter.NextRow()
        num_shares_iter.NextRow()
```


This example code works, but there’s a lot going on with how the loop skips over unmatched rows. Some warning flags might have gone off in your head: *Could this miss any rows? Might it read past the end-of-stream for any of the iterators?*

So how can we make it more readable?

#### An English Description of the Solution

Once again, let’s step back and describe in plain English what we’re trying to do:

* We are reading three row iterators in parallel.
* Whenever the rows' times don't line up, advance the rows so they do line up.
* Then print the aligned rows, and advance the rows again.
* Keep doing this until there are no more matching rows left.


Looking back at the original code, the messiest part was the block dealing with “advance the rows so they do line up.” To present the code more clearly, we can extract all that messy logic into a new function named AdvanceToMatchingTime().

Here’s a new version of the code, making use of this new function:

```python
def PrintStockTransactions():
    stock_iter = ...
    price_iter = ...
    num_shares_iter = ...

    while True:
        time = AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter)
        if time is None:
            return

        # Print the aligned rows.
        print "@", time,
        print stock_iter.ticker_symbol,
        print price_iter.price,
        print num_shares_iter.number_of_shares

        stock_iter.NextRow()
        price_iter.NextRow()
        num_shares_iter.NextRow()
```

As you can see, this code is much easier to understand, as we’ve hidden away all the dirty details of lining up the rows.


#### Applying the Method Recursively

It’s easy to imagine how you would write AdvanceToMatchingTime()—in the worst case, it would look very similar to that ugly block of code from the first version:

```python
def AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter):
    # Iterate through all the rows of the 3 tables in parallel.
    while stock_iter and price_iter and num_shares_iter:
        stock_time = stock_iter.time
        price_time = price_iter.time
        num_shares_time = num_shares_iter.time

        # If all 3 rows don't have the same time, skip over the oldest row
        if stock_time != price_time or stock_time != num_shares_time:
            if stock_time <= price_time and stock_time <= num_shares_time:
                stock_iter.NextRow()
            elif price_time <= stock_time and price_time <= num_shares_time:
                price_iter.NextRow()
            elif num_shares_time <= stock_time and num_shares_time <= price_time:
                num_shares_iter.NextRow()
            else:
                assert False  # impossible
            continue

        assert stock_time == price_time == num_shares_time
        return stock_time
```


But let’s improve that code by applying our method to AdvanceToMatchingTime() as well. Here’s a description of what this function needs to do:

* Look at the times of each current row: if they're aligned, we're done.
* Otherwise, advance any rows that are "behind."
* Keep doing this until the rows are aligned (or one of the iterators has ended).

This description is a lot clearer and more elegant than the previous code. One thing to notice is that the description never mentions stock_iter or other details specific to our problem. This means we can also rename the variables to be simpler and more general. Here’s the resulting code:

```python
def AdvanceToMatchingTime(row_iter1, row_iter2, row_iter3):
    while row_iter1 and row_iter2 and row_iter3:
        t1 = row_iter1.time
        t2 = row_iter2.time
        t3 = row_iter3.time

        if t1 == t2 == t3:
            return t1

        tmax = max(t1, t2, t3)

        # If any row is "behind," advance it.
        # Eventually, this while loop will align them all.
        if t1 < tmax: row_iter1.NextRow()
        if t2 < tmax: row_iter2.NextRow()
        if t3 < tmax: row_iter3.NextRow()
    return None  # no alignment could be found
```

As you can see, this code is a lot clearer than before. The algorithm became simpler, and now there are fewer tricky comparisons. And we used short names like t1 and no longer had to think about the specific database columns involved.


<a name="ch12_summary"></a>
## Summary

This chapter discussed the simple technique of describing your program in plain English and using that description to help you write more natural code. This technique is deceptively simple, but very powerful. Looking at the words and phrases used in your description can also help you identify which subproblems to break off.

But this process of “saying things in plain English” is applicable outside of just writing code. For example, one college computer lab policy states that when a student needs help debugging his program, he first has to explain the problem to a dedicated teddy bear in the corner of the room. Surprisingly, just describing the problem aloud can often help the student figure out a solution. This technique is called “rubber ducking.”

Another way to look at it is this: if you can't describe the problem or your design in words, something is probably missing or undefined. Getting a program (or any idea) into words can really force it into shape.


---

<a name="ch13"></a>
# Chapter 13: WRITING LESS CODE

Knowing when not to code is possibly the most important skill a programmer can learn. Every line of code you write is a line that has to be tested and maintained. By reusing libraries or eliminating features, you can save time and keep your codebase lean and mean.

> KEY IDEA::
The most readable code is no code at all.

<a name="ch13_dont"></a>
## Don’t Bother Implementing That Feature—You Won’t Need It

When you start a project, it’s natural to get excited and think of all the cool features you’ll want to implement. But programmers tend to overestimate how many features are truly essential to their project. A lot of features go unfinished or unused or just complicate the application.

Programmers also tend to underestimate how much effort it takes to implement a feature. We optimistically estimate how long it will take to implement a crude prototype but forget how much extra time is involved in future maintenance, documentation, and the added “weight” to the codebase.


<a name="ch13_req"></a>
## Question and Break Down Your Requirements

Not all programs need to be fast, 100% correct, and able to handle every possible input. If you really scrutinize your requirements, sometimes you can carve out a simpler problem that requires less code. Let’s look at some examples of this.


#### Example: A Store Locator

Suppose you were writing a “store locator” for a business. You think your requirements are:
```
For any given user’s latitude/longitude, find the store with the closest latitude/longitude.
```

To implement this 100% correctly, you would need to handle:

* When the locations are on either side of the International Date Line
* When the locations are near the North or South Pole
* Adjusting for the curvature of the Earth, as “longitudinal degrees per mile” changes

Handling all of these cases requires a fair amount of code.

For your application, however, there are only 30 stores in the state of Texas. In this smaller region, the three issues in the list aren’t that important. As a result, you can reduce your requirements to:
```
For a user near Texas, find (approximately) the closest store in Texas.
```

Solving this problem is easier, as you can get away with just iterating through each store and computing the Euclidean distance between the latitudes/longitudes.

#### Example: Adding a Cache


We once had a Java application that frequently read objects from disk. The speed of the application was limited by these reads, so we wanted to implement caching of some sort. A typical sequence of reads looked like this:
```
    read Object A
    read Object A
    read Object A
    read Object B
    read Object B
    read Object C
    read Object D
    read Object D
```
As you can see, there were a lot of repeated accesses to the same object, so caching should definitely have helped.

When faced with this problem, our first instinct was to use a cache that discards the least recently used items. We didn’t have one available in our library, so we would have had to implement it ourselves. That wasn’t a problem though, as we’ve implemented such a data structure before (it involves both a hash table and a singly linked list—perhaps 100 lines of code in total).

However, we noticed that the repeated accesses were always in a row. So instead of implementing an LRU cache, we just implemented a one-item cache:
```java
    DiskObject lastUsed;  // class member
    DiskObject lookUp(String key) {
        if (lastUsed == null || !lastUsed.key().equals(key)) {
            lastUsed = loadDiskObject(key);
        }
        return lastUsed;
    }
```

This got us 90% of the benefit without much coding, and the program had a small memory footprint, too.

The benefits of “removing requirements” and “solving simpler problems” can’t be overstated. Requirements often interfere with each other in subtle ways. This means that solving half the problem might only take a quarter as much coding effort.

<a name="ch13_small"></a>
## Keeping Your Codebase Small


The best way to cope is to keep your codebase as small and lightweight as possible, even as your project grows. Thus you should:

* Create as much generic “utility” code as possible to remove duplicated code. (See
Chapter 10, Extracting Unrelated Subproblems.)
* Remove unused code or useless features. (See the following sidebar.)
* Keep your project compartmentalized into disconnected subprojects.
* Generally, be conscious of the “weight” of your codebase. Keep it light and nimble.


<a name="ch13_lib"></a>
## Be Familiar with the Libraries Around You

A lot of the time, programmers just aren’t aware that existing libraries can solve their problem. Or sometimes they’ve forgotten what a library can do. It’s important to know the capabilities of your library code so that you can make use of it.

Here’s a modest suggestion: **every once in a while, spend 15 minutes reading the names of all the functions/modules/types in your standard library.** These include the C++ Standard Template Library (STL), the Java API, the built-in Python modules, and others.

The goal isn’t to memorize the whole library. It’s just to get a sense of what’s available, so that next time you’re working on new code you’ll think, “Wait, this sounds similar to something I saw in the API....” We believe doing this work upfront pays off quickly, as you’ll be more inclined to use those libraries in the first place.

#### Example: Lists and Sets in Python


Suppose you have a list in Python (like [2,1,2]) and you want a list of the unique elements (in this case, [2,1]). You could implement this task using a dictionary, which has a list of keys that are guaranteed to be unique:

```python
def unique(elements):
    temp = {}
    for element in elements:
        temp[element] = None  # The value doesn't matter.
    return temp.keys()

unique_elements = unique([2,1,2])
```

But instead you can just use the lesser-known set type:
```python
unique_elements = set([2,1,2]) # Remove duplicates
```
This object is iterable, just like a normal list. If you really want a list object again, you can just use:
```python
unique_elements = list(set([2,1,2])) # Remove duplicates
```
Clearly, set is the right tool for the job here. But if you weren’t aware of the set type, you might produce code like unique() above.



#### Why Reusing Libraries Is Such a Win

A commonly cited statistic is that the average software engineer produces ten shippable lines of code a day. When programmers first hear this, they balk in disbelief—“Ten lines of code? I can write that in a minute!”

The key word is shippable. Each line of code in a mature library represents a fair amount of design, debugging, rewriting, documenting, optimizing, and testing. Any line of code that’s survived this Darwinian process is very valuable. This is why reusing libraries is such a win, in both saving time and having less code to write.


<a name="ch13_unix"></a>
## Example: Using Unix Tools Instead of Coding


When a web server frequently returns 4xx or 5xx HTTP response codes, it’s a sign of a potential problem (4xx being a client error; 5xx being a server error). So we wanted to write a program that parses a web server’s access logs and determines which URLs are causing the most errors.
The access logs typically look something like this:
```sh
1.2.3.4 example.com [24/Aug/2010:01:08:34] "GET /index.html HTTP/1.1" 200 ...
2.3.4.5 example.com [24/Aug/2010:01:14:27] "GET /help?topic=8 HTTP/1.1" 500 ...
3.4.5.6 example.com [24/Aug/2010:01:15:54] "GET /favicon.ico HTTP/1.1" 404 ...
...
```

Generally, they contain lines of this form:
```sh
browser-IP host [date] "GET /url-path HTTP/1.1" HTTP-response-code ...
```

Writing a program to find the most common url-paths with 4xx or 5xx response codes might easily take 20 lines of code in a language like C++ or Java.

Instead, in Unix, you can type this command line:
```sh
cat access.log | awk '{ print $5 " " $7 }' | egrep "[45]..$" \
| sort | uniq -c | sort -nr
```

which produces output like this:
```sh
    95 /favicon.ico 404
    13 /help?topic=8 500
    11 /login 403
    ...
    <count> <path> <http response code>
```

What’s great about this command line is that we’ve avoided writing any “real” code or checking anything into source control.


<a name="ch13_summary"></a>
## Summary

This chapter is about writing as little new code as possible. Each new line of code needs to be tested, documented, and maintained. Further, the more code in your codebase, the “heavier” it gets and the harder it is to develop in.

You can avoid writing new lines of code by:
* Eliminating nonessential features from your product and not overengineering
* Rethinking requirements to solve the easiest version of the problem that still gets the job done
* Staying familiar with standard libraries by periodically reading through their entire APIs


















