# PART I: Surface-level improvements

Naming, commenting, and aesthetics—simple tips that apply to every line of your codebase

* [Chapter 2: Packing Information into Names](#pack_info)

    * [Choosing specific words](#pack_info_spw)
    * [Avoiding generic names (or knowing when to use them)](#pack_info_gen)
    * [Using concrete names instead of abstract names](#pack_info_con)
    * [Attaching extra information to a name, by using a suffix or prefix](#pack_info_exn)
    * [Deciding how long a name should be](#pack_info_lon)
    * [Using name formatting to pack extra information](#pack_info_fon)
    * [Summary](#pack_summary)

* [Chapter 3: Names That Can’t Be Misconstrued](#name_miss)

    * [Example: Filter()](#name_miss_filter)
    * [Example: Clip(text, length)](#name_miss_clip)
    * [Prefer min and max for (Inclusive) Limits](#name_miss_min_max)
    * [Prefer first and last for Inclusive Ranges](#name_miss_first_last)
    * [Prefer begin and end for Inclusive/Exclusive Ranges](#name_miss_begin_end)
    * [Naming Booleans](#name_miss_boolean)
    * [Matching Expectations of Users](#name_miss_users)
    * [Example: Evaluating Multiple Name Candidates](#name_miss_multiple)
    * [Summary](#name_miss_summary)

* [Chapter 4: AESTHETICS](#aes)

    * [Why Do Aesthetics Matter?](#aes_why)
    * [Rearrange Line Breaks to Be Consistent and Compact](#aes_rearre)
    * [Use Methods to Clean Up Irregularity](#aes_irregular)
    * [Use Column Alignment When Helpful](#aes_column)
    * [Pick a Meaningful Order, and Use It Consistently](#aes_pick)
    * [Organize Declarations into Blocks](#aes_organize)
    * [Break Code into “Paragraphs”](#aes_para)
    * [Personal Style versus Consistency](#aes_per)
    * [Summary](#aes_summary)

* [Chapter 5: KNOWING WHAT TO COMMENT](#comment)

    * [What NOT to Comment](#comment_not)
    * [Recording Your Thoughts](#comment_record)
    * [Put Yourself in the Reader’s Shoes](#comment_reader)
    * [Final Thoughts—Getting Over Writer’s Block](#comment_over)
    * [Summary](#comment_summary)

* [Chapter 6: MAKING COMMENTS PRECISE AND COMPACT](#pre_com)

    * [Keep Comments Compact](#pre_com_keep)
    * [Avoid Ambiguous Pronouns](#pre_com_avoid)
    * [Polish Sloppy Sentences](#pre_com_polish)
    * [Describe Function Behavior Precisely](#pre_com_desc)
    * [Use Input/Output Examples That Illustrate Corner Cases](#pre_com_cor)
    * [State the Intent of Your Code](#pre_com_intent)
    * [“Named Function Parameter” Comments](#pre_com_named)
    * [Use Information-Dense Words](#pre_com_dense)
    * [Summary](#pre_com__summary)


---
<a name="pack_info"></a>
# Chapter 2: Packing Information into Names

<a name="pack_info_spw"></a>
## Choosing specific words

> KEY IDEA:: It’s better to be clear and precise than to be cute.

```sh
# bad
GetPage()

# good
FetchPage() or DownloadPage()
```



```sh
# bad
Size()

# good
Height()
NumNodes()
MemoryBytes()
```

```sh
# bad
Stop()

# good
Kill()
Pause()
Resume()
```

Here are some examples of a word, as well as more “colorful” versions that might apply to your situation:

Word | Alternatives
--- | ---
send | deliver, dispatch, announce, distribute, route
find | search, extract, locate, recover
start | launch, create, begin, open
make | create, set up, build, generate, compose, add, new


<a name="pack_info_gen"></a>
## Avoiding generic names (or knowing when to use them)

> ADVICE:: The name retval doesn’t pack much information. Instead, use a name that describes the variable’s value.

```javascript
// example
var euclidean_norm = function (v) {
    var retval = 0.0;
    for (var i = 0; i < v.length; i += 1)
        retval += v[i] * v[i];
    return Math.sqrt(retval);
};


// bad
var retval

// good
var sum_squares
```


> ADVICE::
The name `tmp` should be used only in cases when being short-lived and temporary is the most important fact about that variable.

```java
// bad
String tmp = user.name();
tmp += " " + user.phone_number(); tmp += " " + user.email();
...
template.set("user_info", tmp);

// good
tmp_file = tempfile.NamedTemporaryFile() ...
SaveData(tmp_file, ...)
```


> Loop Iterators

```c++
// bad
for (int i = 0; i < clubs.size(); i++)
    for (int j = 0; j < clubs[i].members.size(); j++)
        for (int k = 0; k < users.size(); k++) if (clubs[i].members[k] == users[j])
            cout << "user[" << j << "] is in club[" << i << "]" << endl;

// good (ci, mi, ui)
if (clubs[ci].members[mi] == users[ui])
```


> ADVICE::
If you’re going to use a generic name like tmp, it, or retval, have a good reason for doing so.



<a name="pack_info_con"></a>
## Prefer Concrete Names over Abstract Names

```c++
// Ex1: which tests whether the server can listen on a given TCP/IP port

// abstract
ServerCanStart();

// concrete
CanListenOnPort();



// Ex2:

// abstract
--run_locally

// concrete
--extra_logging
--use_local_database
```


<a name="pack_info_exn"></a>
## Attaching extra information to a name, by using a suffix or prefix

```c++
// bad
string id = "af84ef845cd8";

// good
string hex_id = "af84ef845cd8";
```




#### Values with Units
If your variable is a measurement (such as an amount of time or a number of bytes), it’s helpful to encode the units into the variable’s name.

```js
// Ex: JavaScript code that measures the load time of a web page:

// bad
var start = (new Date()).getTime(); // top of the page
...
var elapsed = (new Date()).getTime() - start; // bottom of the page document
writeln("Load time was: " + elapsed + " seconds");



// good
var start_ms = (new Date()).getTime(); // top of the page
...
var elapsed_ms = (new Date()).getTime() - start_ms; // bottom of the page document.
writeln("Load time was: " + elapsed_ms / 1000 + " seconds");

```

Function parameter | Renaming parameter to encode units
--- | ---
Start(int delay) | delay → delay_secs
CreateCache(int size) | size → size_mb
ThrottleDownload(float limit) | limit → max_kbps
Rotate(float angle) | angle → degrees_cw


#### Encoding Other Important Attributes
You shouldn’t use attributes like unescaped_ or _utf8 for every variable in your program. They’re most important in places where a bug can easily sneak in if someone mistakes what the variable is, especially if the consequences are dire, as with a security bug. Essentially, if it’s a critical thing to understand, put it in the name.

Situation | Variable name | Better name
--- | --- | ---
A password is in “plaintext” and should be encrypted before further processing | password | plaintext_password
A user-provided comment that needs escaping before being displayed | comment | unescaped_comment
Bytes of html have been converted to UTF-8 | html | html_utf8
Incoming data has been “url encoded” | data | data_urlenc

[Hungarian notation](https://msdn.microsoft.com/en-us/library/aa260976(VS.60).aspx) is a system of naming used widely inside Microsoft. It encodes the “type” of every variable into the name’s prefix. Here are some examples:

Name | Meaning
--- | ---
pLast | A pointer (p) to the last element in some data structure
pszBuffer | A pointer (p) to a zero-terminated (z) string (s) buffer
cch | A count (c) of characters (ch)
mpcopx | A map (m) from a pointer to a color (pco) to a pointer to an x-axis length (px)


<a name="pack_info_lon"></a>
## Deciding how long a name should be

#### Shorter Names Are Okay for Shorter Scope
```c++
// OK for short scope
if (debug) {
    map<string,int> m;
    LookUpNamesNumbers(&m);
    Print(m);
}


// NG for long scope
LookUpNamesNumbers(&m);
Print(m);
```



#### Typing Long Names—Not a Problem Anymore
Every programming text editor we’ve seen has “word completion” built in.

Editor | Command
--- | ---
Vi | Ctrl-p
Emacs | Meta-/ (hit ESC, then /)
Eclipse | Alt-/
IntelliJ IDEA | Alt-/
TextMate | ESC



#### Acronyms and Abbreviations
```sh
# bad
class BEManager # instead of BackEndManager

# ok
doc # instead of document
str # instead of string
```


#### Throwing Out Unneeded Words
```sh
ConvertToString() # => ToString()

DoServeLoop() # => ServeLoop()
```




<a name="pack_info_fon"></a>
## Using name formatting to pack extra information

The way you use underscores, dashes, and capitalization can also pack more information in a name. For example, here is some C++ code that follows the [formatting conventions used for Google open source projects:](https://google.github.io/styleguide/cppguide.html)

```c++
static const int kMaxOpenFiles = 100;
class LogReader {
    public:
    void OpenFile(string local_file);

    private:
    int offset_; DISALLOW_COPY_AND_ASSIGN(LogReader);
};
```




#### Other Formatting Conventions

```js
var x = new DatePicker(); // DatePicker() is a "constructor" function
var y = pageHeight(); // pageHeight() is an ordinary function


var $all_images = $("img"); // $all_images is a jQuery object
var height = 250; // height is not
```


```html
<!-- underscores to separate words in IDs and dashes to separate words in classes: -->
<div id="middle_column" class="main-content"> ...
```



<a name="pack_summary"></a>
## Summary

The single theme for this chapter is: **pack information into your names**. By this, we mean that the reader can extract a lot of information just from reading the name.

Here are some specific tips we covered:

* **Use specific words**—for example, instead of Get, words like Fetch or Download might be better, depending on the context.
* **Avoid generic names** like tmp and retval, unless there’s a specific reason to use them.
* **Use concrete names** that describe things in more detail—the name ServerCanStart() is vague compared to CanListenOnPort().
* **Attach important details** to variable names—for example, append _ms to a variable whose value is in milliseconds or prepend raw_ to an unprocessed variable that needs escaping.
* **Use longer names for larger scopes**—don’t use cryptic one- or two-letter names for variables that span multiple screens; shorter names are better for variables that span only a few lines.
* **Use capitalization, underscores, and so on in a meaningful way**—for example, you can append “_” to class members to distinguish them from local variables.






---
<a name="name_miss"></a>
# Chapter 3: Names That Can’t Be Misconstrued

> KEY IDEA::
Actively scrutinize your names by asking yourself, “What other meanings could someone interpret from this name?”

<a name="name_miss_filter"></a>
## Example: Filter()

```python
# filter is an ambiguous word.
# It’s unclear whether it means “to pick out” or “to get rid of.”
results = Database.all_objects.filter("year <= 2011")


# If you want “to pick out,” a better name is
results = Database.all_objects.select("year <= 2011")

# If you want “to get rid of,” a better name is
results = Database.all_objects.exclude("year <= 2011")
```



<a name="name_miss_clip"></a>
## Example: Clip(text, length)

```python
# Example:

# Cuts off the end of the text, and appends "..."
def Clip(text, length):
...


# Problem:

#> It removes length from the end? or It truncates to a maximum length?


# Better named:

def Truncate(text, max_chars):
...




```


<a name="name_miss_min_max"></a>
## Prefer min and max for (Inclusive) Limits

> ADVICE::
The clearest way to name a limit is to put max_ or min_ in front of the thing being limited.


```python
# Exapmle:

# cart application needs to stop people from buying more than 10 items at once:
CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() >= CART_TOO_BIG_LIMIT:
        Error("Too many items in cart.")


# Problem:

#> CART_TOO_BIG_LIMIT is an ambiguous name.
#> it’s not clear whether you mean “up to” or “up to and including.”



# Better named:

MAX_ITEMS_IN_CART = 10
if shopping_cart.num_items() > MAX_ITEMS_IN_CART:
    Error("Too many items in cart.")

```



<a name="name_miss_first_last"></a>
## Prefer first and last for Inclusive Ranges

```python
# Example:

print integer_range(start=2, stop=4)


# Problem:

#> Does this print [2,3] or [2,3,4] (or something else)?




# Better named:
set.PrintKeys(first="Bart", last="Maggie")
set.PrintKeys(min=1, max=100)

```



<a name="name_miss_begin_end"></a>
## Prefer begin and end for Inclusive/Exclusive Ranges

In practice, it’s often more convenient to use inclusive/exclusive ranges. For example, if you want to print all the events that happened on October 16, it’s easier to write:
```python
PrintEventsInRange("OCT 16 12:00am", "OCT 17 12:00am")
# than it is to write:
PrintEventsInRange("OCT 16 12:00am", "OCT 16 11:59:59.9999pm")
```
So what is a good pair of names for these parameters? Well, the typical programming
convention for naming an `inclusive/exclusive` range is `begin/end`.


<a name="name_miss_boolean"></a>
## Naming Booleans
```python
# Example:

bool read_password = true;

# Problem:

#> There are two very different interpretations:
#> ・We need to read the password
#> ・The password has already been read


# Better named:
bool user_is_authenticated = true;
bool need_password = true
```

> ADVICE::
In general, adding words like `is, has, can, or` should can make booleans more clear.

```python
# If function were meant to return a boolean
SpaceLeft()  ==> HasSpaceLeft()

# It’s best to avoid negated terms in a name
bool disable_ssl = false; ==> bool use_ssl = true;
```

<a name="name_miss_users"></a>
## Matching Expectations of Users

#### Example: get*()

```java
// Example:

public class StatisticsCollector {
    public void addSample(double x) { ... }

    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}


// Problem:

// => This step might be very expensive if there’s a lot of data!
// => But an unsuspecting programmer might call getMean() carelessly, assuming that it’s an inexpensive call.


// Better Named:

// which sounds more like an expensive operation
public class StatisticsCollector {
    public void addSample(double x) { ... }

    public double computeMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
```




#### Example: list::size()

```c++
// Example:

void ShrinkList(list<Node>& list, int max_size) {
    while (list.size() > max_size) {
        FreeNode(list.back());
        ist.pop_back();
    }
}

// Problem:

// --> The “bug” is that the author didn’t know that list.size() is an O(n) operation—it counts through the linked list node by node, instead of just returning a precalculated count, which makes ShrinkList() an O(n2) operation.

// Better named:
countSize();
countElements();
```



<a name="name_miss_multiple"></a>
## Example: Evaluating Multiple Name Candidates

```python
# Example:

experiment_id: 100
description: "increase font size to 14pt" traffic_fraction: 5%
...
experiment_id: 101
description: "increase font size to 13pt" [other lines identical to experiment_id 100]
...
experiment_id: 102
description: "increase font size to 12pt" [other lines identical to experiment_id 100]





# Best Named:
experiment_id: 100
description: "increase font size to 14pt" traffic_fraction: 5%
...
experiment_id: 101
inherit_from_experiment_id: 100
...
experiment_id: 102
inherit_from_experiment_id: 100
```




<a name="name_miss_summary"></a>
## Summary

* The best names are ones that can’t be misconstrued—the person reading your code will understand it the way you meant it, and no other way. Unfortunately, a lot of English words are ambiguous when it comes to programming, such as filter, length, and limit.
* Before you decide on a name, play devil’s advocate and imagine how your name might be misunderstood. The best names are resistant to misinterpretation.
* When it comes to defining an upper or lower limit for a value, max_ and min_ are good prefixes to use. For inclusive ranges, first and last are good. For inclusive/exclusive ranges, begin and end are best because they’re the most idiomatic.
* When naming a boolean, use words like is and has to make it clear that it’s a boolean. Avoid negated terms (e.g., disable_ssl).
* Beware of users’ expectations about certain words. For example, users may expect get() or size() to be lightweight methods.











---
<a name="aes"></a>
# Chapter 4: AESTHETICS

Good source code should be just as “easy on the eyes.” In this chapter, we’ll show how good use of spacing, alignment, and ordering can make your code easier to read.
Specifically, there are three principles we use:

* Use consistent layout, with patterns the reader can get used to.
* Make similar code look similar.
* Group related lines of code into blocks.

<a name="aes_why"></a>
## Why Do Aesthetics Matter?

Obviously it’s easier to work with code that’s aesthetically pleasing. If you think about it, most of your time programming is spent looking at code! The faster you can skim through your code, the easier it is for everyone to use it.

```java
// Bad Aesthetics Example:

class StatsKeeper {
public:
// A class for keeping track of a series of doubles
   void Add(double d);  // and methods for quick statistics about them
  private:   int count;        /* how many so    far
*/ public:
        double Average();

private:   double minimum;
list<double>
  past_items
      ;double maximum;
};
```

```java
// Better Aesthetics Example:


// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list<double> past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
```




<a name="aes_rearre"></a>
## Rearrange Line Breaks to Be Consistent and Compact

```java
// Bad Example:

public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
                500, /* Kbps */
                80, /* millisecs latency */
                200, /* jitter */
                1 /* packet loss % */);
    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
                    45000, /* Kbps */
                    10, /* millisecs latency */
                    0, /* jitter */
                    0 /* packet loss % */);
    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
                100, /* Kbps */
                400, /* millisecs latency */
                250, /* jitter */
                5 /* packet loss % */);
}
```


Problem:

This example code needed a lot of extra line breaks to fit inside an 80-character limit (this was the coding standard at your company). Unfortunately, that made the definition of t3_fiber look different from its neighbors. The “silhouette” of this code is odd, and it draws attention to t3_fiber for no reason. This doesn’t follow the principle that **“similar code should look similar.”**


```java
// More Consistent:

public class PerformanceTester {
        public static final TcpConnectionSimulator wifi =
            new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */
            200, /* jitter */
            1 /* packet loss % */);
public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);
public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
```



```java
// More Compact:

public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,    1);
    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,      0);
    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,    5);
}
```



<a name="aes_irregular"></a>
## Use Methods to Clean Up Irregularity

```java
// Bad Example:

// Turn a partial_name like "Doug Adams" into "Mr. Douglas Adams".
// If not possible, 'error' is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, "Doug Adams", &error)
    == "Mr. Douglas Adams");
assert(error == "");
assert(ExpandFullName(database_connection, " Jake Brown ", &error)
    == "Mr. Jacob Brown III");
assert(error == "");
assert(ExpandFullName(database_connection, "No Such Guy", &error) == "");
assert(error == "no match found"); assert(ExpandFullName(database_connection, "John", &error) == "");
assert(error == "more than one result");
```



```java
// Used Method to clean

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
        // database_connection is now a class member
        string error;
        string full_name = ExpandFullName(database_connection, partial_name, &error);
        assert(error == expected_error);
        assert(full_name == expected_full_name);
}

CheckFullName("Doug Adams", "Mr. Douglas Adams", "");
CheckFullName(" Jake Brown ", "Mr. Jake Brown III", "");
CheckFullName("No Such Guy", "", "no match found");
CheckFullName("John", "", "more than one result");

```

Even though our goal was just to make the code more aesthetically pleasing, this change has a number of other side benefits:

* It eliminates a lot of the duplicated code from before, making the code more compact.
* The important parts of each test case (the names and error strings) are now by themselves, in plain sight. Before, these strings were interspersed with tokens like database_connection and error, which made it hard to “take in” the code in one eyeful.
* Adding new tests should be much easier now.

The moral of the story is that making code “look pretty” often results in more than just surface improvements—it might help you structure your code better.


<a name="aes_column"></a>
## Use Column Alignment When Helpful

```java
// Column Alignment Examples:


// Ex 1:
// previous example
CheckFullName():
    CheckFullName("Doug Adams"   , "Mr. Douglas Adams" , "");
    CheckFullName(" Jake  Brown ", "Mr. Jake Brown III", "");
    CheckFullName("No Such Guy"  , ""                  , "no match found");
    CheckFullName("John"         , ""                  , "more than one result");


// Ex 2:
// Extract POST parameters to local variables
// easy to find bug
details  = request.POST.get("details")
location = request.POST.get("location")
phone    = equest.POST.get("phone")
email    = request.POST.get("email")
url      = request.POST.get("url")


// Ex 3:
// In the wget codebase, the available command-line options (more than 100 of them) were listed as follows:
commands[] = {
    ...
    { "timeout",        NULL,                   cmd_spec_timeout },
    { "timestamping",   &opt.timestamping,      cmd_boolean },
    { "tries",          &opt.ntry,              cmd_number_inf },
    { "useproxy",       &opt.use_proxy,         cmd_boolean },
    { "useragent",      NULL,                   cmd_spec_useragent },
    ...
};
```




<a name="aes_pick"></a>
## Pick a Meaningful Order, and Use It Consistently

```python
# For instance, these five variable definitions could be written in any order:
details     = request.POST.get('details')
location    = request.POST.get('location')
phone       = request.POST.get('phone')
email       = request.POST.get('email')
url         = request.POST.get('url')

```

In situations like this, it’s helpful to put them in some meaningful order, not just random. Here are some ideas:

* Match the order of the variables to the order of the `<input>` fields on the corresponding HTML form.

* Order them from “most important” to “least important.”
* Order them alphabetically.

```python
# if doesn't order, bug may occur:

if details:  rec.details  = details
if phone:    rec.phone    = phone    # Hey, where did 'location' go ?
if email:    rec.email    = email
if url:      rec.url      = url
if location: rec.location = location # Why is 'location' down here now?

```



<a name="aes_organize"></a>
## Organize Declarations into Blocks

```java
// For Bad Example:

// here’s a C++ class for a frontend server, with all its method declarations:
class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
```


This code isn’t horrible, but the layout certainly doesn’t help the reader digest all those methods. Instead of listing all the methods in one giant block, they should be logically organized into groups, like this:

```java
// Organized Declarations

class FrontendServer {
  public:
    FrontendServer();
    ~FrontendServer();

    // Handlers
    void ViewProfile(HttpRequest* request);
    void SaveProfile(HttpRequest* request);
    void FindFriends(HttpRequest* request);

    // Request/Reply Utilities
    string ExtractQueryParam(HttpRequest* request, string param);
    void ReplyOK(HttpRequest* request, string html);
    void ReplyNotFound(HttpRequest* request, string error);

    // Database Helpers
    void OpenDatabase(string location, string user);
    void CloseDatabase(string location);
};
```


<a name="aes_para"></a>
## Break Code into “Paragraphs”

Written text is broken into paragraphs for a number of reasons:

* It’s a way to group similar ideas together and set them apart from other ideas.
* It provides a visual “stepping stone”—without it, it’s easy to lose your place on the page.
* It facilitates navigation from one paragraph to another.

```python
# Bad Example:

# Import the user's email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn't already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends
    return render("suggested_friends.html", display)
```


```python
def suggest_new_friends(user, email_password):
    # Get the user's friends' email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user's email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren't already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page.
    display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends

    return render("suggested_friends.html", display)
```






<a name="aes_per"></a>
## Personal Style versus Consistency

> KEY IDEA:: Consistent style is more important than the “right” style.


```python
# For instance, where the open brace for a class definition should go:

class Logger {
    ...
};

# or

class Logger
{
    ...
};

```




<a name="aes_summary"></a>
## Summary

Everyone prefers to read code that’s aesthetically pleasing. By “formatting” your code in a consistent, meaningful way, you make it easier and faster to read.
Here are specific techniques we discussed:

* If multiple blocks of code are doing similar things, try to give them the same silhouette.
* Aligning parts of the code into “columns” can make code easy to skim through.
* If code mentions A, B, and C in one place, don’t say B, C, and A in another. Pick a meaningful order and stick with it.
* Use empty lines to break apart large blocks into logical “paragraphs.”





---
<a name="comment"></a>
## Chapter 5: KNOWING WHAT TO COMMENT

The goal of this chapter is to help you realize what you should be commenting. You might think the purpose of commenting is to “explain what the code does,” but that is just a small part of it.

> KEY IDEA::
The purpose of commenting is to help the reader know as much as the writer did.



<a name="comment_not"></a>
## What NOT to Comment

> KEY IDEA::
Don’t comment on facts that can be derived quickly from the code itself.

```java
// All of the comments in this code are worthless:

// The class definition for Account
class Account {
  public:
    // Constructor
    Account();

    // Set the profit member to a new value
    void SetProfit(double profit);

    // Return the profit from this Account
    double GetProfit();
};
```

```python
# remove everything after the second '*'
name = '*'.join(line.split('*')[:2])
```

```c++
// Find the Node in the given subtree, with the given name, using the given depth.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
```

If you want to have a comment here, it might as well elaborate on more important details:
```c++
// Find a Node with the given 'name' or return NULL.
// If depth <= 0, only 'subtree' is inspected.
// If depth == N, only 'subtree' and N levels below are inspected. Node* FindNodeInSubtree(Node* subtree, string name, int depth);
```


#### Don’t Comment Bad Names—Fix the Names Instead

A comment shouldn’t have to make up for a bad name. For example, here’s an innocent- looking comment for a function named CleanReply():
```c++
// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc.
void CleanReply(Request request, Reply reply);
```
Most of the comment is simply explaining what “clean” means. Instead, the phrase “enforce limits” should be moved into the function name:
```c++
// Make sure 'reply' meets the count/byte/etc. limits from the 'request'
void EnforceLimitsFromRequest(Request request, Reply reply);
```

This function name is more “self-documenting.” A good name is better than a good comment because it will be seen everywhere the function is used.

```c++
// Releases the handle for this key. This doesn't modify the actual registry.
void DeleteRegistry(RegistryKey* key);
```

The name DeleteRegistry() sounds like a dangerous function (it deletes the registry?!). The
comment “This doesn’t modify the actual registry” is trying to clear up the confusion. Instead, we could use a more self-documenting name like:
```c++
void ReleaseRegistryHandle(RegistryKey* key);
```

** good code > bad code + good comments**

<a name="comment_record"></a>
## Recording Your Thoughts

A lot of good comments can come out of simply “recording your thoughts”—that is, the important thoughts you had as you were writing the code.

#### Include "Director Commentary"

Movies often have a “director commentary” track where the filmmakers give their insights and tell stories to help you understand how the film was made. Similarly, you should include comments to record valuable insights about the code.

* Here’s an example:
```
    // Surprisingly, a binary tree was 40% faster than a hash table for this data.
    // The cost of computing a hash was more than the left/right comparisons.
```
This comment teaches the reader something and stops any would-be optimizer from wasting their time.


* Here’s another example:
```
    // This heuristic might miss a few words. That's OK; solving this 100% is hard.
```
Without this comment, the reader might think there’s a bug and might waste time trying to come up with test cases that make it fail, or go off and try to fix the bug.


* A comment can also explain why the code isn’t in great shape:
```
    // This class is getting messy. Maybe we should create a 'ResourceNode' subclass to
    // help organize things.
```
This comment acknowledges that the code is messy but also encourages the next person to fix it (with specifics on how to get started). Without the comment, many readers would be intimidated by the messy code and afraid to touch it.


#### Comment the Flaws in Your Code

Don’t be embarrassed to document those flaws. For example, noting when improvements should be made:
```
    // TODO: use a faster algorithm
```
or when code is incomplete:
```
    // TODO(dustin): handle other image formats besides JPEG
```

There are a number of markers that have become popular among programmers:

Marker | Typical meaning
---  | ---
TODO: | Stuff I haven’t gotten around to yet
FIXME: | Known-broken code here
HACK: | Admittedly inelegant solution to a problem
XXX: | Danger! major problem here


#### Comment on Your Constants

```python

NUM_THREADS = 8 # as long as it's >= 2 * num_processors, that's good enough.

NUM_THREADS = 8 # setting it to 1 is probably too low, and setting it to 50 is overkill


# Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;


image_quality = 0.72; # users thought 0.72 gave the best size/quality tradeoff
```


<a name="comment_reader"></a>
## Put Yourself in the Reader’s Shoes

#### Anticipating Likely Questions

When someone else reads your code, there are parts likely to make them think, *Huh? What’s this all about?* Your job is to comment those parts.

For example, take a look at the definition of Clear():
```c++
struct Recorder {
    vector<float> data;
    ...
    void Clear() {
        vector<float>().swap(data); // Huh? Why not just data.clear()?
    }
};
```

When most C++ programmers see this code, they think, Why didn’t he just do data.clear() instead of swapping with an empty vector? Well, it turns out that this is the only way to force a vector to truly relinquish its memory to the memory allocator. It’s a C++ detail that isn’t well known. The bottom line is that it should be commented:

```c++
struct Recorder {
    vector<float> data;
    ...
    void Clear() {
        // Force vector to relinquish its memory (look up "STL swap trick")
        vector<float>().swap(data);
    }
};
```


#### Advertising Likely Pitfalls

When documenting a function or class, a good question to ask yourself is, What is surprising about this code? How might it be misused? Basically, you want to “think ahead” and anticipate the problems that people might run into when using your code.

```c++
void SendEmail(string to, string subject, string body);

// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
```

```python
def FixBrokenHtml(html): ...

# Runtime is O(number_tags * average_tag_depth), so watch out for badly nested inputs.
def FixBrokenHtml(html): ...
```


#### “Big Picture” Comments

Here’s a simple example of a file-level comment:
```
    // This file contains helper functions that provide a more convenient interface to our
    // file system. It handles file permissions and other nitty-gritty details.
```
Don’t get overwhelmed by the thought that you have to write extensive, formal documentation. A few well-chosen sentences are better than nothing at all.


#### Summary Comments

```python
# Find all the items that customers purchased for themselves.
    for customer_id in all_customers:
        for sale in all_sales[customer_id].sales:
            if sale.recipient == customer_id:
                ...
```

```python
def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user's info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
```



<a name="comment_over"></a>
## Final Thoughts—Getting Over Writer’s Block


Notice that we’ve broken down the task of writing a comment into these simpler steps:

1. Write down whatever comment is on your mind.
2. Read the comment, and see what (if anything) needs to be improved.
3. Make improvements.

For example, suppose you’re working on a function and think to yourself, **Oh crap, this stuff will get tricky if there are ever duplicates in this list.** Just write that down:
```
    // Oh crap, this stuff will get tricky if there are ever duplicates in this list.
```
See, was that so hard? It’s actually not that bad of a comment—certainly better than nothing. The language is a little vague though. To fix it, we can just go through each phrase and replace it with something more specific:

* By “oh crap,” you really mean “Careful: this is something to watch out for.”
* By “this stuff,” you mean “the code that’s handling this input.”
* By “will get tricky,” you mean “will be hard to implement.”

The new comment might be:
```
    // Careful: this code doesn't handle duplicates in the list (because that's hard to do)
```




<a name="comment_summary"></a>
## Summary

The purpose of a comment is to help the reader know what the writer knew when writing the code. This whole chapter is about realizing all the not-so-obvious nuggets of information you have about the code and writing those down.

[What not to comment](#comment_not):

* Facts that can be quickly derived from the code itself.
* “Crutch comments” that make up for bad code (such as a bad function name)—fix the code instead.

[Thoughts you should be recording include](#comment_record)::

* Insights about why code is one way and not another (“director commentary”).
* Flaws in your code, by using markers like TODO: or XXX:.
* The “story” for how a constant got its value.

[Put yourself in the reader’s shoes](#comment_reader)::

* Anticipate which parts of your code will make readers say “Huh?” and comment those.
* Document any surprising behavior an average reader wouldn’t expect.
* Use “big picture” comments at the file/class level to explain how all the pieces fit together.
* Summarize blocks of code with comments so that the reader doesn’t get lost in the details.



---
<a name="pre_com"></a>
# Chapter 6: MAKING COMMENTS PRECISE AND COMPACT

This chapter is about how to write comments that are precise and compact.

If you're going to write a comment at all, it might as well be precise—as specific and detailed as possible. On the other hand, comments take up extra space on the screen, and take extra time to read. So comments should also be compact.

> KEY IDEA::
Comments should have a high information-to-space ratio.


<a name="pre_com_keep"></a>
## Keep Comments Compact


Here’s an example of a comment for a C++ type definition:
```c++
    // The int is the CategoryType.
    // The first float in the inner pair is the 'score',
    // the second is the 'weight'.
    typedef hash_map<int, pair<float, float> > ScoreMap;
```
But why use three lines to explain it, when you can illustrate it in just one line?
```c++
    // CategoryType -> (score, weight)
    typedef hash_map<int, pair<float, float> > ScoreMap;
```
Some comments need three lines of space, but this is not one of them.

<a name="pre_com_avoid"></a>
## Avoid Ambiguous Pronouns

Here’s an example:
```c++
// Insert the data into the cache, but check if it's too big first.
```
In this comment, “it” might refer to the data or the cache. You could probably figure that out
by reading the rest of the code. But if you have to do that, what’s the point of the comment?
The safest thing is to “fill in” pronouns if there’s any chance of confusion. In the previous example, let’s assume “it” was “the data”:
```c++
// Insert the data into the cache, but check if the data is too big first.
```
This is the simplest change to make. You could also have restructured the sentence to make
“it” perfectly clear:
```c++
// If the data is small enough, insert it into the cache.
```


<a name="pre_com_polish"></a>
## Polish Sloppy Sentences

In many cases, making a comment more precise goes hand-in-hand with making it more compact.
Here is an example from a web crawler:
```python
    # Depending on whether we've already crawled this URL before, give it a different priority.
```
This sentence might seem okay, but compare it to this version:
```python
    # Give higher priority to URLs we've never crawled before.
```
This sentence is simpler, smaller, and more direct. It also explains that higher priority is given to uncrawled URLs—the previous comment didn’t contain that information.


<a name="pre_com_desc"></a>
## Describe Function Behavior Precisely

Imagine you just wrote a function that counts the number of lines in a file:
```c++
    // Return the number of lines in this file.
    int CountLines(string filename) { ... }
```
This comment isn’t very precise—there are a lot of ways to define a “line.” Here are some corner cases to think about:

* "" (an empty file)—0 or 1 line?
* "hello"—0 or 1 line?
* "hello\n"—1 or 2 lines?
* "hello\n world"—1 or 2 lines?
* "hello\n\r cruel\n world\r"—2, 3, or 4 lines?

The simplest implementation is to count the number of newline (\n) characters. (This is the way the Unix command wc works.) Here’s a better comment to match this implementation:
```c++
    // Count how many newline bytes ('\n') are in the file.
    int CountLines(string filename) { ... }
```
This comment isn’t much longer than the first version, but contains much more information. It tells the reader that the function might return 0 if there are no newlines. It also tells the reader that carriage returns (\r) are ignored.


<a name="pre_com_cor"></a>
## Use Input/Output Examples That Illustrate Corner Cases

For example, here’s a common function that removes parts of a string:
```c++
    // Remove the suffix/prefix of 'chars' from the input 'src'.
    String Strip(String src, String chars) { ... }
```
This comment isn’t very precise because it can’t answer questions such as:

* Is chars a whole substring that is to be removed, or effectively just an unordered set of letters?
* What if there are multiples of chars on the end of src?

Instead, a well-chosen example can answer these questions:
```c++
    // ...
    // Example: Strip("abba/a/ba", "ab") returns "/a/"
    String Strip(String src, String chars) { ... }
```

The example “shows off” the full functionality of Strip(). Note that a simpler example wouldn’t be as useful, if it doesn’t answer those questions:
```c++
    // Example: Strip("ab", "a") returns "b"
```

Here’s another example of a function that could use an illustration:
```c++
    // Rearrange 'v' so that elements < pivot come before those >= pivot;
    // Then return the largest 'i' for which v[i] < pivot (or -1 if none are < pivot)
    int Partition(vector<int>* v, int pivot);
```

This comment is actually very precise, but a little bit hard to visualize. Here’s an example you could include to illustrate things further:
```c++
    // ...
    // Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
    int Partition(vector<int>* v, int pivot);
```

There are a number of points to mention about the specific example input/output we chose:

* The pivot is equal to elements in the vector to illustrate that edge case.
* We put duplicates in the vector (8) to illustrate that this is an acceptable input.
* The resulting vector is not sorted—if it were, the reader might get the wrong idea.
* Because the return value was 1, we made sure 1 wasn’t also a value in the vector—that would be confusing.


<a name="pre_com_intent"></a>
## State the Intent of Your Code

Here’s an example of such a comment:
```java
    void DisplayProducts(list<Product> products) {
        products.sort(CompareProductByPrice);
        // Iterate through the list in reverse order
        for (list<Product>::reverse_iterator it = products.rbegin(); it != products.rend();
             ++it)
            DisplayPrice(it->price);
        ...
    }
```

All this comment does is just describe the line below it. Instead, consider this better comment:
```java
        // Display each price, from highest to lowest
        for (list<Product>::reverse_iterator it = products.rbegin(); ... )
```

This comment explains what the program is doing at a higher level. This is much more in tune with what the programmer was thinking when she wrote the code.


<a name="pre_com_named"></a>
## “Named Function Parameter” Comments

In languages like Python, you can assign the arguments by name:
```python
def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
```

In languages like C++ and Java, you can’t do this. However, you can use an inline comment to the same effect:
```c++
void Connect(int timeout, bool use_encryption) { ... }

// Call the function with commented parameters
Connect(/* timeout_ms = */ 10, /* use_encryption = */ false);
```

When it comes to boolean arguments, it’s especially important to put /* name = */ in front of the value. Putting the comment behind the value is very confusing:
```c++
// Don't do this!
Connect( ... , false /* use_encryption */);

// Don't do this either!
Connect( ... , false /* = use_encryption */);
```


<a name="pre_com_dense"></a>
## Use Information-Dense Words

For example, suppose your comment were:
```c++
    // This class contains a number of members that store the same information as in the
    // database, but are stored here for speed. When this class is read from later, those
    // members are checked first to see if they exist, and if so are returned; otherwise the
    // database is read from and that data stored in those fields for next time.
```

Instead, you could just say:
```c++
    // This class acts as a caching layer to the database.
```

As another example, a comment such as:
```c++
    // Remove excess whitespace from the street address, and do lots of other cleanup
    // like turn "Avenue" into "Ave." This way, if there are two different street addresses
    // that are typed in slightly differently, they will have the same cleaned-up version and
    // we can detect that these are equal.
```

could instead be:
```c++
    // Canonicalize the street address (remove extra spaces, "Avenue" -> "Ave.", etc.)
```

There are lots of words and phrases that pack a lot of meaning, such as “heuristic,” “brute- force,” “naive solution,” and the like. If you have a comment that feels a bit long-winded, see if it can be described as a typical programming situation.


<a name="pre_com__summary"></a>
## Summary

This chapter is about writing comments that pack as much information into as small a space as possible. Here are the specific tips:

* [Avoid pronouns like “it” and “this” when they can refer to multiple things.](#pre_com_avoid)
* [Describe a function’s behavior with as much precision as is practical.](#pre_com_desc)
* [Illustrate your comments with carefully chosen input/output examples.](#pre_com_cor)
* [State the high-level intent of your code, rather than the obvious details.](#pre_com_intent)
* [Use inline comments (e.g., Function(/* arg = */ ... ) ) to explain mysterious function arguments.](#pre_com_named)
* [Keep your comments brief by using words that pack a lot of meaning.](#pre_com_dense)






















